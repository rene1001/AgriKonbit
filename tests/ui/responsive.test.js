/**
 * Tests d'Affichage UI/UX
 * Ces tests utilisent Playwright pour tester l'interface utilisateur
 */

const { test, expect } = require('@playwright/test');

test.describe('Tests UI/UX - Responsive Design', () => {
  const viewports = {
    mobile: { width: 375, height: 667 },
    tablet: { width: 768, height: 1024 },
    desktop: { width: 1920, height: 1080 }
  };

  test('Page d\'accueil devrait √™tre responsive', async ({ page }) => {
    for (const [device, viewport] of Object.entries(viewports)) {
      await page.setViewportSize(viewport);
      await page.goto('http://localhost:3000');
      
      // V√©rifier que le contenu est visible
      const mainContent = page.locator('main, [role="main"]');
      await expect(mainContent).toBeVisible();
      
      // V√©rifier navigation
      const nav = page.locator('nav, [role="navigation"]');
      await expect(nav).toBeVisible();
      
      console.log(`‚úì Page d'accueil responsive sur ${device}`);
    }
  });

  test('Menu burger devrait appara√Ætre sur mobile', async ({ page }) => {
    await page.setViewportSize(viewports.mobile);
    await page.goto('http://localhost:3000');
    
    // Chercher menu burger (ic√¥ne hamburger)
    const menuButton = page.locator('[aria-label="Menu"], button[aria-expanded]').first();
    
    if (await menuButton.isVisible()) {
      await menuButton.click();
      
      // Menu devrait s'ouvrir
      const mobileMenu = page.locator('.mobile-menu, [role="menu"]');
      await expect(mobileMenu).toBeVisible({ timeout: 2000 });
      
      console.log('‚úì Menu burger fonctionne sur mobile');
    }
  });

  test('Images devraient √™tre optimis√©es et responsive', async ({ page }) => {
    await page.goto('http://localhost:3000');
    
    // V√©rifier que les images ont des attributs responsive
    const images = await page.locator('img').all();
    
    for (const img of images.slice(0, 5)) { // Tester les 5 premi√®res
      const srcset = await img.getAttribute('srcset');
      const loading = await img.getAttribute('loading');
      
      // Au moins srcset OU loading lazy
      if (srcset || loading === 'lazy') {
        console.log('‚úì Image optimis√©e trouv√©e');
      }
    }
  });

  test('Formulaires devraient √™tre utilisables sur mobile', async ({ page }) => {
    await page.setViewportSize(viewports.mobile);
    await page.goto('http://localhost:3000/login');
    
    const emailInput = page.locator('input[type="email"], input[name="email"]').first();
    const passwordInput = page.locator('input[type="password"]').first();
    
    if (await emailInput.isVisible()) {
      // V√©rifier que les inputs sont assez grands pour mobile
      const emailBox = await emailInput.boundingBox();
      expect(emailBox.height).toBeGreaterThan(40); // Hauteur minimale touch-friendly
      
      // Tester la saisie
      await emailInput.fill('test@example.com');
      await passwordInput.fill('password123');
      
      console.log('‚úì Formulaires utilisables sur mobile');
    }
  });

  test('Texte devrait √™tre lisible sur tous les √©crans', async ({ page }) => {
    for (const [device, viewport] of Object.entries(viewports)) {
      await page.setViewportSize(viewport);
      await page.goto('http://localhost:3000');
      
      // V√©rifier taille de police minimale
      const bodyFontSize = await page.evaluate(() => {
        return window.getComputedStyle(document.body).fontSize;
      });
      
      const fontSize = parseInt(bodyFontSize);
      expect(fontSize).toBeGreaterThanOrEqual(14); // Minimum 14px
      
      console.log(`‚úì Taille police ${device}: ${bodyFontSize}`);
    }
  });
});

test.describe('Tests UI/UX - Navigation et Interactions', () => {
  test('Navigation devrait √™tre fluide', async ({ page }) => {
    await page.goto('http://localhost:3000');
    
    // Tester liens de navigation
    const navLinks = page.locator('nav a, [role="navigation"] a');
    const linkCount = await navLinks.count();
    
    if (linkCount > 0) {
      const firstLink = navLinks.first();
      await firstLink.click();
      
      // Attendre navigation
      await page.waitForLoadState('networkidle');
      
      // V√©rifier que l'URL a chang√©
      const url = page.url();
      expect(url).not.toBe('http://localhost:3000/');
      
      console.log('‚úì Navigation fonctionnelle');
    }
  });

  test('Boutons devraient avoir des √©tats visuels', async ({ page }) => {
    await page.goto('http://localhost:3000');
    
    const buttons = page.locator('button');
    const firstButton = buttons.first();
    
    if (await firstButton.isVisible()) {
      // V√©rifier √©tat hover
      await firstButton.hover();
      
      // V√©rifier √©tat focus
      await firstButton.focus();
      const focused = await firstButton.evaluate(el => document.activeElement === el);
      expect(focused).toBe(true);
      
      console.log('‚úì Boutons avec √©tats visuels');
    }
  });

  test('Loading states devraient √™tre visibles', async ({ page }) => {
    await page.goto('http://localhost:3000/products');
    
    // Chercher indicateurs de chargement
    const loader = page.locator('.loader, .spinner, [role="progressbar"]').first();
    
    // Le loader pourrait appara√Ætre bri√®vement
    try {
      await expect(loader).toBeVisible({ timeout: 1000 });
      console.log('‚úì Loading state visible');
    } catch {
      console.log('‚ö† Loading state non d√©tect√© (peut-√™tre trop rapide)');
    }
  });

  test('Messages d\'erreur devraient √™tre clairs', async ({ page }) => {
    await page.goto('http://localhost:3000/login');
    
    // Soumettre formulaire vide
    const submitButton = page.locator('button[type="submit"]').first();
    
    if (await submitButton.isVisible()) {
      await submitButton.click();
      
      // Chercher messages d'erreur
      const errorMessages = page.locator('.error, [role="alert"], .text-red-500');
      
      try {
        await expect(errorMessages.first()).toBeVisible({ timeout: 2000 });
        console.log('‚úì Messages d\'erreur affich√©s');
      } catch {
        console.log('‚ö† Messages d\'erreur non d√©tect√©s');
      }
    }
  });

  test('Toasts/Notifications devraient appara√Ætre', async ({ page }) => {
    await page.goto('http://localhost:3000/login');
    
    // Essayer une action qui d√©clenche une notification
    const emailInput = page.locator('input[type="email"]').first();
    const passwordInput = page.locator('input[type="password"]').first();
    const submitButton = page.locator('button[type="submit"]').first();
    
    if (await emailInput.isVisible()) {
      await emailInput.fill('wrong@email.com');
      await passwordInput.fill('wrongpassword');
      await submitButton.click();
      
      // Chercher toast
      const toast = page.locator('.toast, .notification, [role="status"]');
      
      try {
        await expect(toast.first()).toBeVisible({ timeout: 3000 });
        console.log('‚úì Toast notification fonctionnel');
      } catch {
        console.log('‚ö† Toast non d√©tect√©');
      }
    }
  });
});

test.describe('Tests UI/UX - Animations et Transitions', () => {
  test('Animations devraient √™tre fluides (60fps)', async ({ page }) => {
    await page.goto('http://localhost:3000');
    
    // Mesurer performance animations
    const fps = await page.evaluate(() => {
      return new Promise((resolve) => {
        let lastTime = performance.now();
        let frames = 0;
        
        function checkFrame(time) {
          frames++;
          if (time - lastTime >= 1000) {
            resolve(frames);
          } else {
            requestAnimationFrame(checkFrame);
          }
        }
        requestAnimationFrame(checkFrame);
      });
    });
    
    console.log(`üìä FPS: ${fps}`);
    expect(fps).toBeGreaterThan(50); // Au moins 50 FPS
  });

  test('Transitions entre pages devraient √™tre smooth', async ({ page }) => {
    await page.goto('http://localhost:3000');
    
    const startTime = Date.now();
    
    // Naviguer vers une autre page
    await page.click('a[href*="/products"], a[href*="/about"]').catch(() => {});
    
    await page.waitForLoadState('networkidle');
    
    const transitionTime = Date.now() - startTime;
    console.log(`‚è± Temps de transition: ${transitionTime}ms`);
    
    expect(transitionTime).toBeLessThan(2000); // < 2s
  });
});

test.describe('Tests UI/UX - Formulaires et Validation', () => {
  test('Validation en temps r√©el devrait fonctionner', async ({ page }) => {
    await page.goto('http://localhost:3000/register');
    
    const emailInput = page.locator('input[type="email"]').first();
    
    if (await emailInput.isVisible()) {
      // Entrer email invalide
      await emailInput.fill('invalid-email');
      await emailInput.blur();
      
      // Chercher message d'erreur
      const errorMessage = page.locator('.error, .text-red-500, [role="alert"]');
      
      try {
        await expect(errorMessage.first()).toBeVisible({ timeout: 1000 });
        console.log('‚úì Validation en temps r√©el fonctionne');
      } catch {
        console.log('‚ö† Validation en temps r√©el non d√©tect√©e');
      }
    }
  });

  test('Champs requis devraient √™tre indiqu√©s', async ({ page }) => {
    await page.goto('http://localhost:3000/register');
    
    // Chercher indicateurs de champs requis (*, required, aria-required)
    const requiredInputs = page.locator('input[required], input[aria-required="true"]');
    const count = await requiredInputs.count();
    
    console.log(`‚úì ${count} champs requis trouv√©s`);
    expect(count).toBeGreaterThan(0);
  });

  test('Autocomplete devrait √™tre configur√©', async ({ page }) => {
    await page.goto('http://localhost:3000/login');
    
    const emailInput = page.locator('input[type="email"]').first();
    const passwordInput = page.locator('input[type="password"]').first();
    
    if (await emailInput.isVisible()) {
      const emailAutocomplete = await emailInput.getAttribute('autocomplete');
      const passwordAutocomplete = await passwordInput.getAttribute('autocomplete');
      
      console.log('Autocomplete:', { emailAutocomplete, passwordAutocomplete });
      
      // Email devrait avoir autocomplete="email"
      // Password devrait avoir autocomplete="current-password" ou "new-password"
      expect(emailAutocomplete || passwordAutocomplete).toBeTruthy();
    }
  });
});

test.describe('Tests UI/UX - Internationalisation', () => {
  test('S√©lecteur de langue devrait fonctionner', async ({ page }) => {
    await page.goto('http://localhost:3000');
    
    // Chercher s√©lecteur de langue
    const langSelector = page.locator('[data-testid="language-selector"], select[name="language"], button:has-text("FR"), button:has-text("EN")');
    
    if (await langSelector.first().isVisible()) {
      const initialText = await page.locator('body').textContent();
      
      // Changer de langue
      await langSelector.first().click();
      await page.waitForTimeout(500);
      
      const newText = await page.locator('body').textContent();
      
      // Le texte devrait avoir chang√©
      console.log('‚úì Changement de langue fonctionnel');
    } else {
      console.log('‚ö† S√©lecteur de langue non trouv√©');
    }
  });

  test('Contenu devrait √™tre traduit', async ({ page }) => {
    await page.goto('http://localhost:3000');
    
    // V√©rifier que le contenu n'est pas en cl√©s i18n brutes
    const bodyText = await page.locator('body').textContent();
    
    // Ne devrait pas contenir de cl√©s comme "common.title" ou "{{"
    expect(bodyText).not.toContain('{{');
    expect(bodyText).not.toContain('}}');
    
    console.log('‚úì Contenu traduit correctement');
  });
});

test.describe('Tests UI/UX - Performance Visuelle', () => {
  test('First Contentful Paint devrait √™tre < 1.5s', async ({ page }) => {
    await page.goto('http://localhost:3000');
    
    const fcp = await page.evaluate(() => {
      return new Promise((resolve) => {
        new PerformanceObserver((entryList) => {
          const entries = entryList.getEntries();
          const fcp = entries.find(entry => entry.name === 'first-contentful-paint');
          if (fcp) {
            resolve(fcp.startTime);
          }
        }).observe({ type: 'paint', buffered: true });
      });
    });
    
    console.log(`üìä First Contentful Paint: ${fcp.toFixed(2)}ms`);
    expect(fcp).toBeLessThan(1500);
  });

  test('Cumulative Layout Shift devrait √™tre minimal', async ({ page }) => {
    await page.goto('http://localhost:3000');
    
    await page.waitForLoadState('networkidle');
    
    const cls = await page.evaluate(() => {
      return new Promise((resolve) => {
        let clsValue = 0;
        new PerformanceObserver((entryList) => {
          for (const entry of entryList.getEntries()) {
            if (!entry.hadRecentInput) {
              clsValue += entry.value;
            }
          }
        }).observe({ type: 'layout-shift', buffered: true });
        
        setTimeout(() => resolve(clsValue), 2000);
      });
    });
    
    console.log(`üìä Cumulative Layout Shift: ${cls.toFixed(3)}`);
    expect(cls).toBeLessThan(0.1); // Bon score CLS < 0.1
  });
});
